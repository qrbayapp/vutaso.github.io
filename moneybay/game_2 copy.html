<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C·ªù T∆∞·ªõng AI - Chinese Chess</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            display: flex;
            gap: 30px;
            padding: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Board Container */
        #boardContainer {
            background: linear-gradient(135deg, #8B4513 0%, #654321 100%);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 5px solid #ffd700;
        }

        #chessBoard {
            background: #F5DEB3;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            border: 2px solid #8B4513;
        }

        /* Control Panel */
        #controlPanel {
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 20px;
            color: white;
            min-width: 350px;
            max-width: 400px;
            border: 3px solid #ffd700;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .panel-section {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .panel-title {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .turn-indicator {
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            transition: all 0.3s;
        }

        .turn-red {
            background: linear-gradient(135deg, #ff0000, #cc0000);
            box-shadow: 0 5px 20px rgba(255, 0, 0, 0.5);
        }

        .turn-black {
            background: linear-gradient(135deg, #333333, #000000);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        .control-btn {
            width: 100%;
            padding: 15px;
            margin: 8px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .control-btn.danger {
            background: linear-gradient(135deg, #ff4757 0%, #ff6b81 100%);
        }

        .control-btn.success {
            background: linear-gradient(135deg, #4ecdc4 0%, #45b7d1 100%);
        }

        /* Difficulty Selector */
        .difficulty-selector {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        .difficulty-btn {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .difficulty-btn.active {
            background: linear-gradient(135deg, #4ecdc4 0%, #45b7d1 100%);
            border-color: #4ecdc4;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }

        /* Move History */
        .move-history {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .move-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            font-size: 14px;
        }

        .move-item:nth-child(odd) {
            background: rgba(255, 255, 255, 0.05);
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .stat-label {
            font-size: 12px;
            color: #ccc;
            margin-top: 5px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 4px solid #ffd700;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
            animation: slideDown 0.5s;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-title {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .modal-text {
            font-size: 24px;
            color: white;
            margin-bottom: 30px;
        }

        .modal-btn {
            padding: 15px 40px;
            margin: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .modal-btn:hover {
            transform: scale(1.1);
        }

        /* Thinking Indicator */
        .thinking {
            display: none;
            text-align: center;
            padding: 15px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #ffd700;
        }

        .thinking.active {
            display: block;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 215, 0, 0.3);
            border-top-color: #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Scrollbar */
        .move-history::-webkit-scrollbar {
            width: 8px;
        }

        .move-history::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .move-history::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            #gameContainer {
                flex-direction: column;
                align-items: center;
            }
        }

        /* Captured Pieces */
        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            min-height: 50px;
        }

        .captured-piece {
            font-size: 20px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Chess Board -->
        <div id="boardContainer">
            <canvas id="chessBoard" width="576" height="640"></canvas>
        </div>

        <!-- Control Panel -->
        <div id="controlPanel">
            <div class="panel-section">
                <h2 class="panel-title">üéÆ C·ªú T∆Ø·ªöNG AI</h2>
                <div class="turn-indicator" id="turnIndicator">
                    L∆∞·ª£t: ƒê·ªè üî¥
                </div>
                <div class="thinking" id="thinkingIndicator">
                    <span class="spinner"></span>
                    <span>AI ƒëang suy nghƒ©...</span>
                </div>
            </div>

            <div class="panel-section">
                <h3 style="color: #ffd700; margin-bottom: 15px;">‚öôÔ∏è C√†i ƒê·∫∑t</h3>
                <div class="game-info">
                    <span>ƒê·ªô kh√≥:</span>
                    <span id="difficultyDisplay">Trung B√¨nh</span>
                </div>
                <div class="difficulty-selector">
                    <button class="difficulty-btn" data-level="1">D·ªÖ</button>
                    <button class="difficulty-btn active" data-level="2">TB</button>
                    <button class="difficulty-btn" data-level="3">Kh√≥</button>
                </div>
            </div>

            <div class="panel-section">
                <button class="control-btn success" onclick="game.newGame()">
                    üîÑ V√°n M·ªõi
                </button>
                <button class="control-btn" onclick="game.undoMove()">
                    ‚Ü©Ô∏è ƒêi L·∫°i
                </button>
                <button class="control-btn" onclick="game.toggleHint()">
                    üí° G·ª£i √ù
                </button>
                <button class="control-btn danger" onclick="game.surrender()">
                    üè≥Ô∏è ƒê·∫ßu H√†ng
                </button>
            </div>

            <div class="panel-section">
                <h3 style="color: #ffd700; margin-bottom: 15px;">üìä Th·ªëng K√™</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="movesCount">0</div>
                        <div class="stat-label">N∆∞·ªõc ƒêi</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="capturedCount">0</div>
                        <div class="stat-label">Qu√¢n ƒÇn</div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h3 style="color: #ffd700; margin-bottom: 10px;">üéØ Qu√¢n ƒê√£ ƒÇn</h3>
                <div style="color: #ff6b6b; margin: 10px 0;">ƒê·ªè:</div>
                <div class="captured-pieces" id="capturedRed"></div>
                <div style="color: #333; margin: 10px 0;">ƒêen:</div>
                <div class="captured-pieces" id="capturedBlack"></div>
            </div>

            <div class="panel-section">
                <h3 style="color: #ffd700; margin-bottom: 10px;">üìú L·ªãch S·ª≠</h3>
                <div class="move-history" id="moveHistory"></div>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <div class="modal-title" id="modalTitle">üèÜ CHI·∫æN TH·∫ÆNG!</div>
            <div class="modal-text" id="modalText">B·∫°n ƒë√£ th·∫Øng!</div>
            <button class="modal-btn" onclick="game.closeModal()">ƒê√≥ng</button>
            <button class="modal-btn" onclick="game.newGame(); game.closeModal()">Ch∆°i L·∫°i</button>
        </div>
    </div>

    <script>
        // ==================== CHINESE CHESS GAME ENGINE ====================
        
        class ChineseChess {
            constructor() {
                this.canvas = document.getElementById('chessBoard');
                this.ctx = this.canvas.getContext('2d');
                
                // Board dimensions
                this.boardWidth = 9;
                this.boardHeight = 10;
                this.cellSize = 64;
                
                // Game state
                this.board = [];
                this.currentPlayer = 'red'; // 'red' or 'black'
                this.selectedPiece = null;
                this.validMoves = [];
                this.moveHistory = [];
                this.capturedPieces = { red: [], black: [] };
                this.gameOver = false;
                
                // AI
                this.aiPlayer = 'black';
                this.aiDepth = 2; // Difficulty level
                this.isThinking = false;
                
                // Piece definitions
                this.pieceTypes = {
                    // Red pieces (lowercase)
                    'r': { name: '‰ø•', value: 9, type: 'chariot' },
                    'n': { name: 'ÂÇå', value: 4, type: 'horse' },
                    'b': { name: 'Áõ∏', value: 2, type: 'elephant' },
                    'a': { name: '‰ªï', value: 2, type: 'advisor' },
                    'k': { name: 'Â∏•', value: 10000, type: 'king' },
                    'c': { name: 'ÁÇÆ', value: 4.5, type: 'cannon' },
                    'p': { name: 'ÂÖµ', value: 1, type: 'pawn' },
                    
                    // Black pieces (uppercase)
                    'R': { name: 'Ëªä', value: 9, type: 'chariot' },
                    'N': { name: 'È¶¨', value: 4, type: 'horse' },
                    'B': { name: 'Ë±°', value: 2, type: 'elephant' },
                    'A': { name: 'Â£´', value: 2, type: 'advisor' },
                    'K': { name: 'Â∞á', value: 10000, type: 'king' },
                    'C': { name: 'Á†≤', value: 4.5, type: 'cannon' },
                    'P': { name: 'Âçí', value: 1, type: 'pawn' }
                };
                
                this.initializeGame();
                this.setupEventListeners();
            }
            
            initializeGame() {
                // Initialize board with standard setup
                this.board = [
                    // Black side (top)
                    ['R', 'N', 'B', 'A', 'K', 'A', 'B', 'N', 'R'], // Row 0
                    [null, null, null, null, null, null, null, null, null], // Row 1
                    [null, 'C', null, null, null, null, null, 'C', null], // Row 2
                    ['P', null, 'P', null, 'P', null, 'P', null, 'P'], // Row 3
                    [null, null, null, null, null, null, null, null, null], // Row 4
                    [null, null, null, null, null, null, null, null, null], // Row 5
                    ['p', null, 'p', null, 'p', null, 'p', null, 'p'], // Row 6
                    [null, 'c', null, null, null, null, null, 'c', null], // Row 7
                    [null, null, null, null, null, null, null, null, null], // Row 8
                    ['r', 'n', 'b', 'a', 'k', 'a', 'b', 'n', 'r'] // Row 9 (Red side)
                ];
                
                this.currentPlayer = 'red';
                this.selectedPiece = null;
                this.validMoves = [];
                this.moveHistory = [];
                this.capturedPieces = { red: [], black: [] };
                this.gameOver = false;
                
                this.updateDisplay();
                this.drawBoard();
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => {
                    if (this.gameOver || this.isThinking) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const col = Math.floor(x / this.cellSize);
                    const row = Math.floor(y / this.cellSize);
                    
                    this.handleClick(row, col);
                });
                
                // Difficulty buttons
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        const level = parseInt(btn.dataset.level);
                        this.aiDepth = level;
                        
                        const difficultyNames = ['', 'D·ªÖ', 'Trung B√¨nh', 'Kh√≥'];
                        document.getElementById('difficultyDisplay').textContent = difficultyNames[level];
                    });
                });
            }
            
            handleClick(row, col) {
                if (row < 0 || row >= this.boardHeight || col < 0 || col >= this.boardWidth) return;
                
                const piece = this.board[row][col];
                
                if (this.selectedPiece) {
                    // Try to move
                    if (this.isValidMove(this.selectedPiece.row, this.selectedPiece.col, row, col)) {
                        this.makeMove(this.selectedPiece.row, this.selectedPiece.col, row, col);
                        this.selectedPiece = null;
                        this.validMoves = [];
                        
                        if (!this.gameOver && this.currentPlayer === this.aiPlayer) {
                            setTimeout(() => this.makeAIMove(), 500);
                        }
                    } else if (piece && this.getPieceColor(piece) === this.currentPlayer) {
                        // Select different piece
                        this.selectedPiece = { row, col, piece };
                        this.validMoves = this.getValidMoves(row, col);
                    } else {
                        this.selectedPiece = null;
                        this.validMoves = [];
                    }
                } else if (piece && this.getPieceColor(piece) === this.currentPlayer) {
                    // Select piece
                    this.selectedPiece = { row, col, piece };
                    this.validMoves = this.getValidMoves(row, col);
                }
                
                this.drawBoard();
            }
            
            makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const captured = this.board[toRow][toCol];
                
                // Record move
                this.moveHistory.push({
                    from: { row: fromRow, col: fromCol },
                    to: { row: toRow, col: toCol },
                    piece: piece,
                    captured: captured,
                    player: this.currentPlayer
                });
                
                // Capture piece
                if (captured) {
                    const capturedColor = this.getPieceColor(captured);
                    this.capturedPieces[capturedColor].push(captured);
                    this.updateCapturedDisplay();
                }
                
                // Move piece
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                
                // Check for checkmate
                if (this.isCheckmate(this.getOpponent(this.currentPlayer))) {
                    this.gameOver = true;
                    this.showGameOver(this.currentPlayer);
                }
                
                // Switch player
                this.currentPlayer = this.getOpponent(this.currentPlayer);
                
                this.updateDisplay();
                this.drawBoard();
            }
            
            undoMove() {
                if (this.moveHistory.length === 0) return;
                
                const lastMove = this.moveHistory.pop();
                
                // Restore board state
                this.board[lastMove.from.row][lastMove.from.col] = lastMove.piece;
                this.board[lastMove.to.row][lastMove.to.col] = lastMove.captured;
                
                // Restore captured pieces
                if (lastMove.captured) {
                    const capturedColor = this.getPieceColor(lastMove.captured);
                    const index = this.capturedPieces[capturedColor].indexOf(lastMove.captured);
                    if (index > -1) {
                        this.capturedPieces[capturedColor].splice(index, 1);
                    }
                }
                
                this.currentPlayer = lastMove.player;
                this.selectedPiece = null;
                this.validMoves = [];
                
                // Undo AI move too if it was AI's turn
                if (this.currentPlayer === this.aiPlayer && this.moveHistory.length > 0) {
                    this.undoMove();
                }
                
                this.updateDisplay();
                this.drawBoard();
            }
            
            makeAIMove() {
                if (this.gameOver || this.currentPlayer !== this.aiPlayer) return;
                
                this.isThinking = true;
                document.getElementById('thinkingIndicator').classList.add('active');
                
                setTimeout(() => {
                    const bestMove = this.getBestMove(this.aiDepth);
                    
                    if (bestMove) {
                        this.makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                    }
                    
                    this.isThinking = false;
                    document.getElementById('thinkingIndicator').classList.remove('active');
                }, 300);
            }
            
            getBestMove(depth) {
                let bestScore = -Infinity;
                let bestMove = null;
                const moves = this.getAllValidMoves(this.currentPlayer);
                
                // Shuffle moves for variety
                for (let i = moves.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [moves[i], moves[j]] = [moves[j], moves[i]];
                }
                
                for (const move of moves) {
                    const score = this.minimax(
                        move.fromRow, move.fromCol, move.toRow, move.toCol,
                        depth - 1, -Infinity, Infinity, false
                    );
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                
                return bestMove;
            }
            
            minimax(fromRow, fromCol, toRow, toCol, depth, alpha, beta, isMaximizing) {
                // Simulate move
                const piece = this.board[fromRow][fromCol];
                const captured = this.board[toRow][toCol];
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                
                let score;
                
                if (depth === 0 || this.isCheckmate('red') || this.isCheckmate('black')) {
                    score = this.evaluateBoard();
                } else {
                    const moves = this.getAllValidMoves(isMaximizing ? this.aiPlayer : this.getOpponent(this.aiPlayer));
                    
                    if (isMaximizing) {
                        score = -Infinity;
                        for (const move of moves) {
                            score = Math.max(score, this.minimax(
                                move.fromRow, move.fromCol, move.toRow, move.toCol,
                                depth - 1, alpha, beta, false
                            ));
                            alpha = Math.max(alpha, score);
                            if (beta <= alpha) break;
                        }
                    } else {
                        score = Infinity;
                        for (const move of moves) {
                            score = Math.min(score, this.minimax(
                                move.fromRow, move.fromCol, move.toRow, move.toCol,
                                depth - 1, alpha, beta, true
                            ));
                            beta = Math.min(beta, score);
                            if (beta <= alpha) break;
                        }
                    }
                }
                
                // Undo move
                this.board[fromRow][fromCol] = piece;
                this.board[toRow][toCol] = captured;
                
                return score;
            }
            
            evaluateBoard() {
                let score = 0;
                
                for (let row = 0; row < this.boardHeight; row++) {
                    for (let col = 0; col < this.boardWidth; col++) {
                        const piece = this.board[row][col];
                        if (!piece) continue;
                        
                        const pieceValue = this.pieceTypes[piece].value;
                        const positionValue = this.getPositionValue(piece, row, col);
                        
                        if (this.getPieceColor(piece) === this.aiPlayer) {
                            score += pieceValue + positionValue;
                        } else {
                            score -= pieceValue + positionValue;
                        }
                    }
                }
                
                return score;
            }
            
            getPositionValue(piece, row, col) {
                // Simple position evaluation (center control, advancement)
                let value = 0;
                
                // Center control
                const centerCol = Math.abs(col - 4);
                value += (4 - centerCol) * 0.1;
                
                // Advancement
                if (this.pieceTypes[piece].type === 'pawn') {
                    if (this.getPieceColor(piece) === 'red') {
                        value += (9 - row) * 0.2;
                    } else {
                        value += row * 0.2;
                    }
                }
                
                return value;
            }
            
            getAllValidMoves(player) {
                const moves = [];
                
                for (let row = 0; row < this.boardHeight; row++) {
                    for (let col = 0; col < this.boardWidth; col++) {
                        const piece = this.board[row][col];
                        if (piece && this.getPieceColor(piece) === player) {
                            const validMoves = this.getValidMoves(row, col);
                            for (const move of validMoves) {
                                moves.push({
                                    fromRow: row,
                                    fromCol: col,
                                    toRow: move.row,
                                    toCol: move.col
                                });
                            }
                        }
                    }
                }
                
                return moves;
            }
            
            getValidMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const type = this.pieceTypes[piece].type;
                let moves = [];
                
                switch(type) {
                    case 'chariot':
                        moves = this.getChariotMoves(row, col);
                        break;
                    case 'horse':
                        moves = this.getHorseMoves(row, col);
                        break;
                    case 'elephant':
                        moves = this.getElephantMoves(row, col);
                        break;
                    case 'advisor':
                        moves = this.getAdvisorMoves(row, col);
                        break;
                    case 'king':
                        moves = this.getKingMoves(row, col);
                        break;
                    case 'cannon':
                        moves = this.getCannonMoves(row, col);
                        break;
                    case 'pawn':
                        moves = this.getPawnMoves(row, col);
                        break;
                }
                
                // Filter out moves that would put own king in check
                return moves.filter(move => 
                    !this.wouldBeInCheck(row, col, move.row, move.col)
                );
            }
            
            getChariotMoves(row, col) {
                const moves = [];
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                
                for (const [dx, dy] of directions) {
                    let newRow = row + dx;
                    let newCol = col + dy;
                    
                    while (this.isInBounds(newRow, newCol)) {
                        if (this.board[newRow][newCol]) {
                            if (this.canCapture(row, col, newRow, newCol)) {
                                moves.push({ row: newRow, col: newCol });
                            }
                            break;
                        }
                        moves.push({ row: newRow, col: newCol });
                        newRow += dx;
                        newCol += dy;
                    }
                }
                
                return moves;
            }
            
            getHorseMoves(row, col) {
                const moves = [];
                const deltas = [
                    { block: [-1, 0], moves: [[-2, -1], [-2, 1]] },
                    { block: [1, 0], moves: [[2, -1], [2, 1]] },
                    { block: [0, -1], moves: [[-1, -2], [1, -2]] },
                    { block: [0, 1], moves: [[-1, 2], [1, 2]] }
                ];
                
                for (const { block, moves: horseMoves } of deltas) {
                    const blockRow = row + block[0];
                    const blockCol = col + block[1];
                    
                    if (this.isInBounds(blockRow, blockCol) && !this.board[blockRow][blockCol]) {
                        for (const [dr, dc] of horseMoves) {
                            const newRow = row + dr;
                            const newCol = col + dc;
                            
                            if (this.isInBounds(newRow, newCol) && 
                                (!this.board[newRow][newCol] || this.canCapture(row, col, newRow, newCol))) {
                                moves.push({ row: newRow, col: newCol });
                            }
                        }
                    }
                }
                
                return moves;
            }
            
            getElephantMoves(row, col) {
                const moves = [];
                const color = this.getPieceColor(this.board[row][col]);
                const deltas = [
                    { block: [-1, -1], move: [-2, -2] },
                    { block: [-1, 1], move: [-2, 2] },
                    { block: [1, -1], move: [2, -2] },
                    { block: [1, 1], move: [2, 2] }
                ];
                
                for (const { block, move } of deltas) {
                    const blockRow = row + block[0];
                    const blockCol = col + block[1];
                    const newRow = row + move[0];
                    const newCol = col + move[1];
                    
                    // Can't cross river
                    if (color === 'red' && newRow < 5) continue;
                    if (color === 'black' && newRow > 4) continue;
                    
                    if (this.isInBounds(blockRow, blockCol) && !this.board[blockRow][blockCol] &&
                        this.isInBounds(newRow, newCol) && 
                        (!this.board[newRow][newCol] || this.canCapture(row, col, newRow, newCol))) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
                
                return moves;
            }
            
            getAdvisorMoves(row, col) {
                const moves = [];
                const color = this.getPieceColor(this.board[row][col]);
                const palace = color === 'red' ? 
                    { rowMin: 7, rowMax: 9, colMin: 3, colMax: 5 } :
                    { rowMin: 0, rowMax: 2, colMin: 3, colMax: 5 };
                
                const deltas = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                
                for (const [dr, dc] of deltas) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (newRow >= palace.rowMin && newRow <= palace.rowMax &&
                        newCol >= palace.colMin && newCol <= palace.colMax &&
                        (!this.board[newRow][newCol] || this.canCapture(row, col, newRow, newCol))) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
                
                return moves;
            }
            
            getKingMoves(row, col) {
                const moves = [];
                const color = this.getPieceColor(this.board[row][col]);
                const palace = color === 'red' ? 
                    { rowMin: 7, rowMax: 9, colMin: 3, colMax: 5 } :
                    { rowMin: 0, rowMax: 2, colMin: 3, colMax: 5 };
                
                const deltas = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                
                for (const [dr, dc] of deltas) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (newRow >= palace.rowMin && newRow <= palace.rowMax &&
                        newCol >= palace.colMin && newCol <= palace.colMax &&
                        (!this.board[newRow][newCol] || this.canCapture(row, col, newRow, newCol))) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
                
                return moves;
            }
            
            getCannonMoves(row, col) {
                const moves = [];
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                
                for (const [dx, dy] of directions) {
                    let newRow = row + dx;
                    let newCol = col + dy;
                    let jumped = false;
                    
                    while (this.isInBounds(newRow, newCol)) {
                        if (this.board[newRow][newCol]) {
                            if (!jumped) {
                                jumped = true;
                            } else {
                                if (this.canCapture(row, col, newRow, newCol)) {
                                    moves.push({ row: newRow, col: newCol });
                                }
                                break;
                            }
                        } else if (!jumped) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        newRow += dx;
                        newCol += dy;
                    }
                }
                
                return moves;
            }
            
            getPawnMoves(row, col) {
                const moves = [];
                const color = this.getPieceColor(this.board[row][col]);
                const hasPassedRiver = color === 'red' ? row < 5 : row > 4;
                
                // Forward
                const forward = color === 'red' ? -1 : 1;
                const newRow = row + forward;
                
                if (this.isInBounds(newRow, col) && 
                    (!this.board[newRow][col] || this.canCapture(row, col, newRow, col))) {
                    moves.push({ row: newRow, col });
                }
                
                // Sideways (only after crossing river)
                if (hasPassedRiver) {
                    for (const dc of [-1, 1]) {
                        const newCol = col + dc;
                        if (this.isInBounds(row, newCol) && 
                            (!this.board[row][newCol] || this.canCapture(row, col, row, newCol))) {
                            moves.push({ row, col: newCol });
                        }
                    }
                }
                
                return moves;
            }
            
            isInBounds(row, col) {
                return row >= 0 && row < this.boardHeight && col >= 0 && col < this.boardWidth;
            }
            
            canCapture(fromRow, fromCol, toRow, toCol) {
                const fromPiece = this.board[fromRow][fromCol];
                const toPiece = this.board[toRow][toCol];
                return toPiece && this.getPieceColor(fromPiece) !== this.getPieceColor(toPiece);
            }
            
            isValidMove(fromRow, fromCol, toRow, toCol) {
                const validMoves = this.getValidMoves(fromRow, fromCol);
                return validMoves.some(move => move.row === toRow && move.col === toCol);
            }
            
            wouldBeInCheck(fromRow, fromCol, toRow, toCol) {
                // Simulate move
                const piece = this.board[fromRow][fromCol];
                const captured = this.board[toRow][toCol];
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                
                const inCheck = this.isInCheck(this.getPieceColor(piece));
                
                // Undo move
                this.board[fromRow][fromCol] = piece;
                this.board[toRow][toCol] = captured;
                
                return inCheck;
            }
            
            isInCheck(color) {
                const kingPos = this.findKing(color);
                if (!kingPos) return false;
                
                const opponent = this.getOpponent(color);
                
                for (let row = 0; row < this.boardHeight; row++) {
                    for (let col = 0; col < this.boardWidth; col++) {
                        const piece = this.board[row][col];
                        if (piece && this.getPieceColor(piece) === opponent) {
                            const moves = this.getValidMoves(row, col);
                            if (moves.some(move => move.row === kingPos.row && move.col === kingPos.col)) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            isCheckmate(color) {
                if (!this.isInCheck(color)) return false;
                
                for (let row = 0; row < this.boardHeight; row++) {
                    for (let col = 0; col < this.boardWidth; col++) {
                        const piece = this.board[row][col];
                        if (piece && this.getPieceColor(piece) === color) {
                            const moves = this.getValidMoves(row, col);
                            if (moves.length > 0) return false;
                        }
                    }
                }
                
                return true;
            }
            
            findKing(color) {
                for (let row = 0; row < this.boardHeight; row++) {
                    for (let col = 0; col < this.boardWidth; col++) {
                        const piece = this.board[row][col];
                        if (piece && this.getPieceColor(piece) === color && 
                            this.pieceTypes[piece].type === 'king') {
                            return { row, col };
                        }
                    }
                }
                return null;
            }
            
            getPieceColor(piece) {
                return piece === piece.toLowerCase() ? 'red' : 'black';
            }
            
            getOpponent(color) {
                return color === 'red' ? 'black' : 'red';
            }
            
            drawBoard() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw board background
                this.ctx.fillStyle = '#F5DEB3';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 2;
                
                // Vertical lines
                for (let i = 0; i < this.boardWidth; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo((i + 0.5) * this.cellSize, 0.5 * this.cellSize);
                    if (i === 0 || i === this.boardWidth - 1) {
                        this.ctx.lineTo((i + 0.5) * this.cellSize, (this.boardHeight - 0.5) * this.cellSize);
                    } else {
                        this.ctx.lineTo((i + 0.5) * this.cellSize, 4.5 * this.cellSize);
                        this.ctx.moveTo((i + 0.5) * this.cellSize, 5.5 * this.cellSize);
                        this.ctx.lineTo((i + 0.5) * this.cellSize, (this.boardHeight - 0.5) * this.cellSize);
                    }
                    this.ctx.stroke();
                }
                
                // Horizontal lines
                for (let i = 0; i < this.boardHeight; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0.5 * this.cellSize, (i + 0.5) * this.cellSize);
                    this.ctx.lineTo((this.boardWidth - 0.5) * this.cellSize, (i + 0.5) * this.cellSize);
                    this.ctx.stroke();
                }
                
                // Draw palace diagonals
                this.drawPalace(0); // Black
                this.drawPalace(7); // Red
                
                // Draw river text
                this.ctx.font = 'bold 24px Arial';
                this.ctx.fillStyle = '#8B4513';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Ê•ö Ê≤≥', this.cellSize * 2.5, this.cellSize * 5);
                this.ctx.fillText('Êº¢ Áïå', this.cellSize * 6.5, this.cellSize * 5);
                
                // Draw valid moves
                this.ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                for (const move of this.validMoves) {
                    this.ctx.beginPath();
                    this.ctx.arc(
                        (move.col + 0.5) * this.cellSize,
                        (move.row + 0.5) * this.cellSize,
                        10, 0, Math.PI * 2
                    );
                    this.ctx.fill();
                }
                
                // Draw pieces
                for (let row = 0; row < this.boardHeight; row++) {
                    for (let col = 0; col < this.boardWidth; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            this.drawPiece(piece, row, col, 
                                this.selectedPiece && 
                                this.selectedPiece.row === row && 
                                this.selectedPiece.col === col);
                        }
                    }
                }
            }
            
            drawPalace(startRow) {
                // Draw X in palace
                this.ctx.beginPath();
                this.ctx.moveTo(3.5 * this.cellSize, (startRow + 0.5) * this.cellSize);
                this.ctx.lineTo(5.5 * this.cellSize, (startRow + 2.5) * this.cellSize);
                this.ctx.moveTo(5.5 * this.cellSize, (startRow + 0.5) * this.cellSize);
                this.ctx.lineTo(3.5 * this.cellSize, (startRow + 2.5) * this.cellSize);
                this.ctx.stroke();
            }
            
            drawPiece(piece, row, col, selected) {
                const x = (col + 0.5) * this.cellSize;
                const y = (row + 0.5) * this.cellSize;
                const radius = this.cellSize * 0.4;
                
                // Piece background
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                
                const color = this.getPieceColor(piece);
                const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, color === 'red' ? '#ff6b6b' : '#333333');
                gradient.addColorStop(1, color === 'red' ? '#cc0000' : '#000000');
                this.ctx.fillStyle = gradient;
                this.ctx.fill();
                
                // Selection highlight
                if (selected) {
                    this.ctx.strokeStyle = '#ffd700';
                    this.ctx.lineWidth = 4;
                    this.ctx.stroke();
                }
                
                // Piece border
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // Piece character
                this.ctx.font = 'bold 32px Arial';
                this.ctx.fillStyle = color === 'red' ? '#ffffff' : '#ffffff';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(this.pieceTypes[piece].name, x, y);
            }
            
            updateDisplay() {
                // Turn indicator
                const turnIndicator = document.getElementById('turnIndicator');
                if (this.currentPlayer === 'red') {
                    turnIndicator.textContent = 'L∆∞·ª£t: ƒê·ªè üî¥';
                    turnIndicator.className = 'turn-indicator turn-red';
                } else {
                    turnIndicator.textContent = 'L∆∞·ª£t: ƒêen ‚ö´';
                    turnIndicator.className = 'turn-indicator turn-black';
                }
                
                // Move count
                document.getElementById('movesCount').textContent = this.moveHistory.length;
                
                // Captured count
                const totalCaptured = this.capturedPieces.red.length + this.capturedPieces.black.length;
                document.getElementById('capturedCount').textContent = totalCaptured;
                
                // Move history
                this.updateMoveHistory();
            }
            
            updateMoveHistory() {
                const historyDiv = document.getElementById('moveHistory');
                historyDiv.innerHTML = '';
                
                for (let i = this.moveHistory.length - 1; i >= 0; i--) {
                    const move = this.moveHistory[i];
                    const moveDiv = document.createElement('div');
                    moveDiv.className = 'move-item';
                    
                    const fromPos = this.positionToString(move.from.row, move.from.col);
                    const toPos = this.positionToString(move.to.row, move.to.col);
                    const playerColor = move.player === 'red' ? 'üî¥' : '‚ö´';
                    const captured = move.captured ? ' ‚úñÔ∏è ' + this.pieceTypes[move.captured].name : '';
                    
                    moveDiv.textContent = `${i + 1}. ${playerColor} ${this.pieceTypes[move.piece].name} ${fromPos}‚Üí${toPos}${captured}`;
                    historyDiv.appendChild(moveDiv);
                }
            }
            
            updateCapturedDisplay() {
                const redDiv = document.getElementById('capturedRed');
                const blackDiv = document.getElementById('capturedBlack');
                
                redDiv.innerHTML = '';
                blackDiv.innerHTML = '';
                
                this.capturedPieces.red.forEach(piece => {
                    const span = document.createElement('span');
                    span.className = 'captured-piece';
                    span.textContent = this.pieceTypes[piece].name;
                    redDiv.appendChild(span);
                });
                
                this.capturedPieces.black.forEach(piece => {
                    const span = document.createElement('span');
                    span.className = 'captured-piece';
                    span.textContent = this.pieceTypes[piece].name;
                    blackDiv.appendChild(span);
                });
            }
            
            positionToString(row, col) {
                const cols = ['‚ë†', '‚ë°', '‚ë¢', '‚ë£', '‚ë§', '‚ë•', '‚ë¶', '‚ëß', '‚ë®'];
                return `${cols[col]}${row + 1}`;
            }
            
            showGameOver(winner) {
                document.getElementById('modalTitle').textContent = winner === 'red' ? 'üèÜ B·∫†N TH·∫ÆNG!' : 'üíÄ B·∫†N THUA!';
                document.getElementById('modalText').textContent = 
                    winner === 'red' ? 'Ch√∫c m·ª´ng! B·∫°n ƒë√£ chi·∫øn th·∫Øng!' : 'AI ƒë√£ th·∫Øng! Ch∆°i l·∫°i nh√©!';
                document.getElementById('gameOverModal').style.display = 'flex';
            }
            
            closeModal() {
                document.getElementById('gameOverModal').style.display = 'none';
            }
            
            newGame() {
                this.initializeGame();
            }
            
            toggleHint() {
                if (this.currentPlayer === this.aiPlayer) return;
                
                const bestMove = this.getBestMove(1);
                if (bestMove) {
                    this.selectedPiece = {
                        row: bestMove.fromRow,
                        col: bestMove.fromCol,
                        piece: this.board[bestMove.fromRow][bestMove.fromCol]
                    };
                    this.validMoves = this.getValidMoves(bestMove.fromRow, bestMove.fromCol);
                    this.drawBoard();
                    
                    // Highlight the best move
                    setTimeout(() => {
                        this.ctx.strokeStyle = '#ffd700';
                        this.ctx.lineWidth = 4;
                        this.ctx.beginPath();
                        this.ctx.arc(
                            (bestMove.toCol + 0.5) * this.cellSize,
                            (bestMove.toRow + 0.5) * this.cellSize,
                            this.cellSize * 0.4,
                            0, Math.PI * 2
                        );
                        this.ctx.stroke();
                    }, 100);
                }
            }
            
            surrender() {
                if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën ƒë·∫ßu h√†ng?')) {
                    this.gameOver = true;
                    this.showGameOver('black');
                }
            }
        }
        
        // Initialize game
        const game = new ChineseChess();
        window.game = game;
        
        console.log('%c‚ôüÔ∏è C·ªú T∆Ø·ªöNG AI LOADED! ‚ôüÔ∏è', 'color: #ffd700; font-size: 24px; font-weight: bold;');
    </script>
</body>
</html>
